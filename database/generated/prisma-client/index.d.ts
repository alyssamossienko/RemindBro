// Code generated by Prisma (prisma@1.22.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  cron: (where?: CronWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  recipient: (where?: RecipientWhereInput) => Promise<boolean>;
  reminder: (where?: ReminderWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  cron: (where: CronWhereUniqueInput) => CronPromise;
  crons: (
    args?: {
      where?: CronWhereInput;
      orderBy?: CronOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Cron>;
  cronsConnection: (
    args?: {
      where?: CronWhereInput;
      orderBy?: CronOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CronConnectionPromise;
  notification: (where: NotificationWhereUniqueInput) => NotificationPromise;
  notifications: (
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Notification>;
  notificationsConnection: (
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NotificationConnectionPromise;
  recipient: (where: RecipientWhereUniqueInput) => RecipientPromise;
  recipients: (
    args?: {
      where?: RecipientWhereInput;
      orderBy?: RecipientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Recipient>;
  recipientsConnection: (
    args?: {
      where?: RecipientWhereInput;
      orderBy?: RecipientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RecipientConnectionPromise;
  reminder: (where: ReminderWhereUniqueInput) => ReminderPromise;
  reminders: (
    args?: {
      where?: ReminderWhereInput;
      orderBy?: ReminderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Reminder>;
  remindersConnection: (
    args?: {
      where?: ReminderWhereInput;
      orderBy?: ReminderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ReminderConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCron: (data: CronCreateInput) => CronPromise;
  updateCron: (
    args: { data: CronUpdateInput; where: CronWhereUniqueInput }
  ) => CronPromise;
  updateManyCrons: (
    args: { data: CronUpdateManyMutationInput; where?: CronWhereInput }
  ) => BatchPayloadPromise;
  upsertCron: (
    args: {
      where: CronWhereUniqueInput;
      create: CronCreateInput;
      update: CronUpdateInput;
    }
  ) => CronPromise;
  deleteCron: (where: CronWhereUniqueInput) => CronPromise;
  deleteManyCrons: (where?: CronWhereInput) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (
    args: { data: NotificationUpdateInput; where: NotificationWhereUniqueInput }
  ) => NotificationPromise;
  updateManyNotifications: (
    args: {
      data: NotificationUpdateManyMutationInput;
      where?: NotificationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertNotification: (
    args: {
      where: NotificationWhereUniqueInput;
      create: NotificationCreateInput;
      update: NotificationUpdateInput;
    }
  ) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createRecipient: (data: RecipientCreateInput) => RecipientPromise;
  updateRecipient: (
    args: { data: RecipientUpdateInput; where: RecipientWhereUniqueInput }
  ) => RecipientPromise;
  updateManyRecipients: (
    args: {
      data: RecipientUpdateManyMutationInput;
      where?: RecipientWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRecipient: (
    args: {
      where: RecipientWhereUniqueInput;
      create: RecipientCreateInput;
      update: RecipientUpdateInput;
    }
  ) => RecipientPromise;
  deleteRecipient: (where: RecipientWhereUniqueInput) => RecipientPromise;
  deleteManyRecipients: (where?: RecipientWhereInput) => BatchPayloadPromise;
  createReminder: (data: ReminderCreateInput) => ReminderPromise;
  updateReminder: (
    args: { data: ReminderUpdateInput; where: ReminderWhereUniqueInput }
  ) => ReminderPromise;
  updateManyReminders: (
    args: { data: ReminderUpdateManyMutationInput; where?: ReminderWhereInput }
  ) => BatchPayloadPromise;
  upsertReminder: (
    args: {
      where: ReminderWhereUniqueInput;
      create: ReminderCreateInput;
      update: ReminderUpdateInput;
    }
  ) => ReminderPromise;
  deleteReminder: (where: ReminderWhereUniqueInput) => ReminderPromise;
  deleteManyReminders: (where?: ReminderWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  cron: (
    where?: CronSubscriptionWhereInput
  ) => CronSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  recipient: (
    where?: RecipientSubscriptionWhereInput
  ) => RecipientSubscriptionPayloadSubscription;
  reminder: (
    where?: ReminderSubscriptionWhereInput
  ) => ReminderSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Status = "SCHEDULED" | "PENDING" | "SUCCESS" | "FAILLURE";

export type ContactMethod = "EMAIL" | "SMS";

export type RecipientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "contactMethod_ASC"
  | "contactMethod_DESC"
  | "contactInfo_ASC"
  | "contactInfo_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReminderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "message_ASC"
  | "message_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "scheduledDelivery_ASC"
  | "scheduledDelivery_DESC"
  | "status_ASC"
  | "status_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CronOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "plainText_ASC"
  | "plainText_DESC"
  | "cronText_ASC"
  | "cronText_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface UserUpdateWithoutRecipientDataInput {
  email?: String;
  name?: String;
  password?: String;
  reminders?: ReminderUpdateManyWithoutAuthorInput;
  type?: Int;
}

export type CronWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CronUpdateWithoutReminderDataInput {
  plainText?: String;
  cronText?: String;
}

export interface NotificationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parentReminder?: ReminderWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  scheduledDelivery?: DateTimeInput;
  scheduledDelivery_not?: DateTimeInput;
  scheduledDelivery_in?: DateTimeInput[] | DateTimeInput;
  scheduledDelivery_not_in?: DateTimeInput[] | DateTimeInput;
  scheduledDelivery_lt?: DateTimeInput;
  scheduledDelivery_lte?: DateTimeInput;
  scheduledDelivery_gt?: DateTimeInput;
  scheduledDelivery_gte?: DateTimeInput;
  status?: Status;
  status_not?: Status;
  status_in?: Status[] | Status;
  status_not_in?: Status[] | Status;
  AND?: NotificationWhereInput[] | NotificationWhereInput;
  OR?: NotificationWhereInput[] | NotificationWhereInput;
  NOT?: NotificationWhereInput[] | NotificationWhereInput;
}

export interface CronUpsertWithoutReminderInput {
  update: CronUpdateWithoutReminderDataInput;
  create: CronCreateWithoutReminderInput;
}

export interface CronWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  plainText?: String;
  plainText_not?: String;
  plainText_in?: String[] | String;
  plainText_not_in?: String[] | String;
  plainText_lt?: String;
  plainText_lte?: String;
  plainText_gt?: String;
  plainText_gte?: String;
  plainText_contains?: String;
  plainText_not_contains?: String;
  plainText_starts_with?: String;
  plainText_not_starts_with?: String;
  plainText_ends_with?: String;
  plainText_not_ends_with?: String;
  cronText?: String;
  cronText_not?: String;
  cronText_in?: String[] | String;
  cronText_not_in?: String[] | String;
  cronText_lt?: String;
  cronText_lte?: String;
  cronText_gt?: String;
  cronText_gte?: String;
  cronText_contains?: String;
  cronText_not_contains?: String;
  cronText_starts_with?: String;
  cronText_not_starts_with?: String;
  cronText_ends_with?: String;
  cronText_not_ends_with?: String;
  reminder?: ReminderWhereInput;
  AND?: CronWhereInput[] | CronWhereInput;
  OR?: CronWhereInput[] | CronWhereInput;
  NOT?: CronWhereInput[] | CronWhereInput;
}

export interface NotificationUpdateManyWithoutParentReminderInput {
  create?:
    | NotificationCreateWithoutParentReminderInput[]
    | NotificationCreateWithoutParentReminderInput;
  delete?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  disconnect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  update?:
    | NotificationUpdateWithWhereUniqueWithoutParentReminderInput[]
    | NotificationUpdateWithWhereUniqueWithoutParentReminderInput;
  upsert?:
    | NotificationUpsertWithWhereUniqueWithoutParentReminderInput[]
    | NotificationUpsertWithWhereUniqueWithoutParentReminderInput;
  deleteMany?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
  updateMany?:
    | NotificationUpdateManyWithWhereNestedInput[]
    | NotificationUpdateManyWithWhereNestedInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  reminders_every?: ReminderWhereInput;
  reminders_some?: ReminderWhereInput;
  reminders_none?: ReminderWhereInput;
  recipient_every?: RecipientWhereInput;
  recipient_some?: RecipientWhereInput;
  recipient_none?: RecipientWhereInput;
  type?: Int;
  type_not?: Int;
  type_in?: Int[] | Int;
  type_not_in?: Int[] | Int;
  type_lt?: Int;
  type_lte?: Int;
  type_gt?: Int;
  type_gte?: Int;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface NotificationUpdateWithWhereUniqueWithoutParentReminderInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateWithoutParentReminderDataInput;
}

export interface ReminderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  message?: String;
  message_not?: String;
  message_in?: String[] | String;
  message_not_in?: String[] | String;
  message_lt?: String;
  message_lte?: String;
  message_gt?: String;
  message_gte?: String;
  message_contains?: String;
  message_not_contains?: String;
  message_starts_with?: String;
  message_not_starts_with?: String;
  message_ends_with?: String;
  message_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  recipients_every?: RecipientWhereInput;
  recipients_some?: RecipientWhereInput;
  recipients_none?: RecipientWhereInput;
  author?: UserWhereInput;
  frequency?: CronWhereInput;
  sentReminders_every?: NotificationWhereInput;
  sentReminders_some?: NotificationWhereInput;
  sentReminders_none?: NotificationWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: ReminderWhereInput[] | ReminderWhereInput;
  OR?: ReminderWhereInput[] | ReminderWhereInput;
  NOT?: ReminderWhereInput[] | ReminderWhereInput;
}

export interface NotificationUpdateWithoutParentReminderDataInput {
  scheduledDelivery?: DateTimeInput;
  status?: Status;
}

export interface RecipientWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  reminders_every?: ReminderWhereInput;
  reminders_some?: ReminderWhereInput;
  reminders_none?: ReminderWhereInput;
  contactMethod?: ContactMethod;
  contactMethod_not?: ContactMethod;
  contactMethod_in?: ContactMethod[] | ContactMethod;
  contactMethod_not_in?: ContactMethod[] | ContactMethod;
  contactInfo?: String;
  contactInfo_not?: String;
  contactInfo_in?: String[] | String;
  contactInfo_not_in?: String[] | String;
  contactInfo_lt?: String;
  contactInfo_lte?: String;
  contactInfo_gt?: String;
  contactInfo_gte?: String;
  contactInfo_contains?: String;
  contactInfo_not_contains?: String;
  contactInfo_starts_with?: String;
  contactInfo_not_starts_with?: String;
  contactInfo_ends_with?: String;
  contactInfo_not_ends_with?: String;
  user?: UserWhereInput;
  AND?: RecipientWhereInput[] | RecipientWhereInput;
  OR?: RecipientWhereInput[] | RecipientWhereInput;
  NOT?: RecipientWhereInput[] | RecipientWhereInput;
}

export interface ReminderCreateWithoutRecipientsInput {
  title?: String;
  message?: String;
  description?: String;
  author: UserCreateOneWithoutRemindersInput;
  frequency?: CronCreateOneWithoutReminderInput;
  sentReminders?: NotificationCreateManyWithoutParentReminderInput;
}

export interface UserUpsertWithoutRemindersInput {
  update: UserUpdateWithoutRemindersDataInput;
  create: UserCreateWithoutRemindersInput;
}

export interface CronUpdateInput {
  plainText?: String;
  cronText?: String;
  reminder?: ReminderUpdateOneRequiredWithoutFrequencyInput;
}

export interface NotificationUpsertWithWhereUniqueWithoutParentReminderInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateWithoutParentReminderDataInput;
  create: NotificationCreateWithoutParentReminderInput;
}

export interface ReminderUpdateOneRequiredWithoutFrequencyInput {
  create?: ReminderCreateWithoutFrequencyInput;
  update?: ReminderUpdateWithoutFrequencyDataInput;
  upsert?: ReminderUpsertWithoutFrequencyInput;
  connect?: ReminderWhereUniqueInput;
}

export interface ReminderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ReminderWhereInput;
  AND?: ReminderSubscriptionWhereInput[] | ReminderSubscriptionWhereInput;
  OR?: ReminderSubscriptionWhereInput[] | ReminderSubscriptionWhereInput;
  NOT?: ReminderSubscriptionWhereInput[] | ReminderSubscriptionWhereInput;
}

export interface ReminderUpdateWithoutFrequencyDataInput {
  title?: String;
  message?: String;
  description?: String;
  recipients?: RecipientUpdateManyWithoutRemindersInput;
  author?: UserUpdateOneRequiredWithoutRemindersInput;
  sentReminders?: NotificationUpdateManyWithoutParentReminderInput;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NotificationWhereInput;
  AND?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  OR?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  NOT?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
}

export interface RecipientUpdateManyWithoutRemindersInput {
  create?:
    | RecipientCreateWithoutRemindersInput[]
    | RecipientCreateWithoutRemindersInput;
  delete?: RecipientWhereUniqueInput[] | RecipientWhereUniqueInput;
  connect?: RecipientWhereUniqueInput[] | RecipientWhereUniqueInput;
  disconnect?: RecipientWhereUniqueInput[] | RecipientWhereUniqueInput;
  update?:
    | RecipientUpdateWithWhereUniqueWithoutRemindersInput[]
    | RecipientUpdateWithWhereUniqueWithoutRemindersInput;
  upsert?:
    | RecipientUpsertWithWhereUniqueWithoutRemindersInput[]
    | RecipientUpsertWithWhereUniqueWithoutRemindersInput;
  deleteMany?: RecipientScalarWhereInput[] | RecipientScalarWhereInput;
  updateMany?:
    | RecipientUpdateManyWithWhereNestedInput[]
    | RecipientUpdateManyWithWhereNestedInput;
}

export interface CronSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CronWhereInput;
  AND?: CronSubscriptionWhereInput[] | CronSubscriptionWhereInput;
  OR?: CronSubscriptionWhereInput[] | CronSubscriptionWhereInput;
  NOT?: CronSubscriptionWhereInput[] | CronSubscriptionWhereInput;
}

export interface RecipientUpdateWithWhereUniqueWithoutRemindersInput {
  where: RecipientWhereUniqueInput;
  data: RecipientUpdateWithoutRemindersDataInput;
}

export interface UserUpdateInput {
  email?: String;
  name?: String;
  password?: String;
  reminders?: ReminderUpdateManyWithoutAuthorInput;
  recipient?: RecipientUpdateManyWithoutUserInput;
  type?: Int;
}

export interface RecipientUpdateWithoutRemindersDataInput {
  name?: String;
  contactMethod?: ContactMethod;
  contactInfo?: String;
  user?: UserUpdateOneRequiredWithoutRecipientInput;
}

export interface UserCreateInput {
  email?: String;
  name: String;
  password: String;
  reminders?: ReminderCreateManyWithoutAuthorInput;
  recipient?: RecipientCreateManyWithoutUserInput;
  type?: Int;
}

export interface UserUpdateOneRequiredWithoutRecipientInput {
  create?: UserCreateWithoutRecipientInput;
  update?: UserUpdateWithoutRecipientDataInput;
  upsert?: UserUpsertWithoutRecipientInput;
  connect?: UserWhereUniqueInput;
}

export interface ReminderUpdateInput {
  title?: String;
  message?: String;
  description?: String;
  recipients?: RecipientUpdateManyWithoutRemindersInput;
  author?: UserUpdateOneRequiredWithoutRemindersInput;
  frequency?: CronUpdateOneWithoutReminderInput;
  sentReminders?: NotificationUpdateManyWithoutParentReminderInput;
}

export interface ReminderUpdateOneRequiredWithoutSentRemindersInput {
  create?: ReminderCreateWithoutSentRemindersInput;
  update?: ReminderUpdateWithoutSentRemindersDataInput;
  upsert?: ReminderUpsertWithoutSentRemindersInput;
  connect?: ReminderWhereUniqueInput;
}

export interface ReminderCreateInput {
  title?: String;
  message?: String;
  description?: String;
  recipients?: RecipientCreateManyWithoutRemindersInput;
  author: UserCreateOneWithoutRemindersInput;
  frequency?: CronCreateOneWithoutReminderInput;
  sentReminders?: NotificationCreateManyWithoutParentReminderInput;
}

export interface ReminderUpdateManyWithoutAuthorInput {
  create?:
    | ReminderCreateWithoutAuthorInput[]
    | ReminderCreateWithoutAuthorInput;
  delete?: ReminderWhereUniqueInput[] | ReminderWhereUniqueInput;
  connect?: ReminderWhereUniqueInput[] | ReminderWhereUniqueInput;
  disconnect?: ReminderWhereUniqueInput[] | ReminderWhereUniqueInput;
  update?:
    | ReminderUpdateWithWhereUniqueWithoutAuthorInput[]
    | ReminderUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | ReminderUpsertWithWhereUniqueWithoutAuthorInput[]
    | ReminderUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: ReminderScalarWhereInput[] | ReminderScalarWhereInput;
  updateMany?:
    | ReminderUpdateManyWithWhereNestedInput[]
    | ReminderUpdateManyWithWhereNestedInput;
}

export interface RecipientUpdateInput {
  name?: String;
  reminders?: ReminderUpdateManyWithoutRecipientsInput;
  contactMethod?: ContactMethod;
  contactInfo?: String;
  user?: UserUpdateOneRequiredWithoutRecipientInput;
}

export interface ReminderUpdateWithWhereUniqueWithoutAuthorInput {
  where: ReminderWhereUniqueInput;
  data: ReminderUpdateWithoutAuthorDataInput;
}

export interface RecipientCreateInput {
  name: String;
  reminders?: ReminderCreateManyWithoutRecipientsInput;
  contactMethod?: ContactMethod;
  contactInfo?: String;
  user: UserCreateOneWithoutRecipientInput;
}

export interface ReminderUpdateWithoutAuthorDataInput {
  title?: String;
  message?: String;
  description?: String;
  recipients?: RecipientUpdateManyWithoutRemindersInput;
  frequency?: CronUpdateOneWithoutReminderInput;
  sentReminders?: NotificationUpdateManyWithoutParentReminderInput;
}

export interface ReminderUpsertWithoutSentRemindersInput {
  update: ReminderUpdateWithoutSentRemindersDataInput;
  create: ReminderCreateWithoutSentRemindersInput;
}

export interface CronUpdateOneWithoutReminderInput {
  create?: CronCreateWithoutReminderInput;
  update?: CronUpdateWithoutReminderDataInput;
  upsert?: CronUpsertWithoutReminderInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CronWhereUniqueInput;
}

export interface ReminderCreateOneWithoutFrequencyInput {
  create?: ReminderCreateWithoutFrequencyInput;
  connect?: ReminderWhereUniqueInput;
}

export interface NotificationUpdateInput {
  parentReminder?: ReminderUpdateOneRequiredWithoutSentRemindersInput;
  scheduledDelivery?: DateTimeInput;
  status?: Status;
}

export interface RecipientCreateManyWithoutRemindersInput {
  create?:
    | RecipientCreateWithoutRemindersInput[]
    | RecipientCreateWithoutRemindersInput;
  connect?: RecipientWhereUniqueInput[] | RecipientWhereUniqueInput;
}

export interface ReminderCreateWithoutSentRemindersInput {
  title?: String;
  message?: String;
  description?: String;
  recipients?: RecipientCreateManyWithoutRemindersInput;
  author: UserCreateOneWithoutRemindersInput;
  frequency?: CronCreateOneWithoutReminderInput;
}

export interface UserCreateOneWithoutRecipientInput {
  create?: UserCreateWithoutRecipientInput;
  connect?: UserWhereUniqueInput;
}

export interface ReminderCreateOneWithoutSentRemindersInput {
  create?: ReminderCreateWithoutSentRemindersInput;
  connect?: ReminderWhereUniqueInput;
}

export interface ReminderCreateManyWithoutAuthorInput {
  create?:
    | ReminderCreateWithoutAuthorInput[]
    | ReminderCreateWithoutAuthorInput;
  connect?: ReminderWhereUniqueInput[] | ReminderWhereUniqueInput;
}

export interface NotificationCreateInput {
  parentReminder: ReminderCreateOneWithoutSentRemindersInput;
  scheduledDelivery: DateTimeInput;
  status?: Status;
}

export interface CronCreateOneWithoutReminderInput {
  create?: CronCreateWithoutReminderInput;
  connect?: CronWhereUniqueInput;
}

export interface CronUpdateManyMutationInput {
  plainText?: String;
  cronText?: String;
}

export interface NotificationCreateManyWithoutParentReminderInput {
  create?:
    | NotificationCreateWithoutParentReminderInput[]
    | NotificationCreateWithoutParentReminderInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
}

export interface ReminderUpsertWithoutFrequencyInput {
  update: ReminderUpdateWithoutFrequencyDataInput;
  create: ReminderCreateWithoutFrequencyInput;
}

export interface UserCreateOneWithoutRemindersInput {
  create?: UserCreateWithoutRemindersInput;
  connect?: UserWhereUniqueInput;
}

export interface NotificationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  scheduledDelivery?: DateTimeInput;
  scheduledDelivery_not?: DateTimeInput;
  scheduledDelivery_in?: DateTimeInput[] | DateTimeInput;
  scheduledDelivery_not_in?: DateTimeInput[] | DateTimeInput;
  scheduledDelivery_lt?: DateTimeInput;
  scheduledDelivery_lte?: DateTimeInput;
  scheduledDelivery_gt?: DateTimeInput;
  scheduledDelivery_gte?: DateTimeInput;
  status?: Status;
  status_not?: Status;
  status_in?: Status[] | Status;
  status_not_in?: Status[] | Status;
  AND?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
  OR?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
  NOT?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
}

export interface RecipientCreateManyWithoutUserInput {
  create?: RecipientCreateWithoutUserInput[] | RecipientCreateWithoutUserInput;
  connect?: RecipientWhereUniqueInput[] | RecipientWhereUniqueInput;
}

export interface NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput;
  data: NotificationUpdateManyDataInput;
}

export interface ReminderCreateManyWithoutRecipientsInput {
  create?:
    | ReminderCreateWithoutRecipientsInput[]
    | ReminderCreateWithoutRecipientsInput;
  connect?: ReminderWhereUniqueInput[] | ReminderWhereUniqueInput;
}

export interface NotificationUpdateManyDataInput {
  scheduledDelivery?: DateTimeInput;
  status?: Status;
}

export interface RecipientSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RecipientWhereInput;
  AND?: RecipientSubscriptionWhereInput[] | RecipientSubscriptionWhereInput;
  OR?: RecipientSubscriptionWhereInput[] | RecipientSubscriptionWhereInput;
  NOT?: RecipientSubscriptionWhereInput[] | RecipientSubscriptionWhereInput;
}

export interface ReminderUpsertWithWhereUniqueWithoutAuthorInput {
  where: ReminderWhereUniqueInput;
  update: ReminderUpdateWithoutAuthorDataInput;
  create: ReminderCreateWithoutAuthorInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  name?: String;
  password?: String;
  type?: Int;
}

export interface ReminderScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  message?: String;
  message_not?: String;
  message_in?: String[] | String;
  message_not_in?: String[] | String;
  message_lt?: String;
  message_lte?: String;
  message_gt?: String;
  message_gte?: String;
  message_contains?: String;
  message_not_contains?: String;
  message_starts_with?: String;
  message_not_starts_with?: String;
  message_ends_with?: String;
  message_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: ReminderScalarWhereInput[] | ReminderScalarWhereInput;
  OR?: ReminderScalarWhereInput[] | ReminderScalarWhereInput;
  NOT?: ReminderScalarWhereInput[] | ReminderScalarWhereInput;
}

export interface ReminderUpdateManyMutationInput {
  title?: String;
  message?: String;
  description?: String;
}

export interface ReminderUpdateManyWithWhereNestedInput {
  where: ReminderScalarWhereInput;
  data: ReminderUpdateManyDataInput;
}

export interface RecipientUpdateManyMutationInput {
  name?: String;
  contactMethod?: ContactMethod;
  contactInfo?: String;
}

export interface ReminderUpdateManyDataInput {
  title?: String;
  message?: String;
  description?: String;
}

export interface NotificationUpdateManyMutationInput {
  scheduledDelivery?: DateTimeInput;
  status?: Status;
}

export interface UserUpsertWithoutRecipientInput {
  update: UserUpdateWithoutRecipientDataInput;
  create: UserCreateWithoutRecipientInput;
}

export interface CronCreateInput {
  plainText: String;
  cronText: String;
  reminder: ReminderCreateOneWithoutFrequencyInput;
}

export interface RecipientUpsertWithWhereUniqueWithoutRemindersInput {
  where: RecipientWhereUniqueInput;
  update: RecipientUpdateWithoutRemindersDataInput;
  create: RecipientCreateWithoutRemindersInput;
}

export interface RecipientCreateWithoutRemindersInput {
  name: String;
  contactMethod?: ContactMethod;
  contactInfo?: String;
  user: UserCreateOneWithoutRecipientInput;
}

export interface RecipientScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  contactMethod?: ContactMethod;
  contactMethod_not?: ContactMethod;
  contactMethod_in?: ContactMethod[] | ContactMethod;
  contactMethod_not_in?: ContactMethod[] | ContactMethod;
  contactInfo?: String;
  contactInfo_not?: String;
  contactInfo_in?: String[] | String;
  contactInfo_not_in?: String[] | String;
  contactInfo_lt?: String;
  contactInfo_lte?: String;
  contactInfo_gt?: String;
  contactInfo_gte?: String;
  contactInfo_contains?: String;
  contactInfo_not_contains?: String;
  contactInfo_starts_with?: String;
  contactInfo_not_starts_with?: String;
  contactInfo_ends_with?: String;
  contactInfo_not_ends_with?: String;
  AND?: RecipientScalarWhereInput[] | RecipientScalarWhereInput;
  OR?: RecipientScalarWhereInput[] | RecipientScalarWhereInput;
  NOT?: RecipientScalarWhereInput[] | RecipientScalarWhereInput;
}

export interface ReminderCreateWithoutAuthorInput {
  title?: String;
  message?: String;
  description?: String;
  recipients?: RecipientCreateManyWithoutRemindersInput;
  frequency?: CronCreateOneWithoutReminderInput;
  sentReminders?: NotificationCreateManyWithoutParentReminderInput;
}

export interface RecipientUpdateManyWithWhereNestedInput {
  where: RecipientScalarWhereInput;
  data: RecipientUpdateManyDataInput;
}

export interface NotificationCreateWithoutParentReminderInput {
  scheduledDelivery: DateTimeInput;
  status?: Status;
}

export interface RecipientUpdateManyDataInput {
  name?: String;
  contactMethod?: ContactMethod;
  contactInfo?: String;
}

export interface RecipientCreateWithoutUserInput {
  name: String;
  reminders?: ReminderCreateManyWithoutRecipientsInput;
  contactMethod?: ContactMethod;
  contactInfo?: String;
}

export interface UserUpdateOneRequiredWithoutRemindersInput {
  create?: UserCreateWithoutRemindersInput;
  update?: UserUpdateWithoutRemindersDataInput;
  upsert?: UserUpsertWithoutRemindersInput;
  connect?: UserWhereUniqueInput;
}

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutRemindersDataInput {
  email?: String;
  name?: String;
  password?: String;
  recipient?: RecipientUpdateManyWithoutUserInput;
  type?: Int;
}

export type ReminderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface RecipientUpdateManyWithoutUserInput {
  create?: RecipientCreateWithoutUserInput[] | RecipientCreateWithoutUserInput;
  delete?: RecipientWhereUniqueInput[] | RecipientWhereUniqueInput;
  connect?: RecipientWhereUniqueInput[] | RecipientWhereUniqueInput;
  disconnect?: RecipientWhereUniqueInput[] | RecipientWhereUniqueInput;
  update?:
    | RecipientUpdateWithWhereUniqueWithoutUserInput[]
    | RecipientUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | RecipientUpsertWithWhereUniqueWithoutUserInput[]
    | RecipientUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: RecipientScalarWhereInput[] | RecipientScalarWhereInput;
  updateMany?:
    | RecipientUpdateManyWithWhereNestedInput[]
    | RecipientUpdateManyWithWhereNestedInput;
}

export interface ReminderUpdateWithoutSentRemindersDataInput {
  title?: String;
  message?: String;
  description?: String;
  recipients?: RecipientUpdateManyWithoutRemindersInput;
  author?: UserUpdateOneRequiredWithoutRemindersInput;
  frequency?: CronUpdateOneWithoutReminderInput;
}

export interface RecipientUpdateWithWhereUniqueWithoutUserInput {
  where: RecipientWhereUniqueInput;
  data: RecipientUpdateWithoutUserDataInput;
}

export interface UserCreateWithoutRecipientInput {
  email?: String;
  name: String;
  password: String;
  reminders?: ReminderCreateManyWithoutAuthorInput;
  type?: Int;
}

export interface RecipientUpdateWithoutUserDataInput {
  name?: String;
  reminders?: ReminderUpdateManyWithoutRecipientsInput;
  contactMethod?: ContactMethod;
  contactInfo?: String;
}

export interface UserCreateWithoutRemindersInput {
  email?: String;
  name: String;
  password: String;
  recipient?: RecipientCreateManyWithoutUserInput;
  type?: Int;
}

export interface ReminderUpdateManyWithoutRecipientsInput {
  create?:
    | ReminderCreateWithoutRecipientsInput[]
    | ReminderCreateWithoutRecipientsInput;
  delete?: ReminderWhereUniqueInput[] | ReminderWhereUniqueInput;
  connect?: ReminderWhereUniqueInput[] | ReminderWhereUniqueInput;
  disconnect?: ReminderWhereUniqueInput[] | ReminderWhereUniqueInput;
  update?:
    | ReminderUpdateWithWhereUniqueWithoutRecipientsInput[]
    | ReminderUpdateWithWhereUniqueWithoutRecipientsInput;
  upsert?:
    | ReminderUpsertWithWhereUniqueWithoutRecipientsInput[]
    | ReminderUpsertWithWhereUniqueWithoutRecipientsInput;
  deleteMany?: ReminderScalarWhereInput[] | ReminderScalarWhereInput;
  updateMany?:
    | ReminderUpdateManyWithWhereNestedInput[]
    | ReminderUpdateManyWithWhereNestedInput;
}

export type RecipientWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface RecipientUpsertWithWhereUniqueWithoutUserInput {
  where: RecipientWhereUniqueInput;
  update: RecipientUpdateWithoutUserDataInput;
  create: RecipientCreateWithoutUserInput;
}

export interface ReminderUpsertWithWhereUniqueWithoutRecipientsInput {
  where: ReminderWhereUniqueInput;
  update: ReminderUpdateWithoutRecipientsDataInput;
  create: ReminderCreateWithoutRecipientsInput;
}

export interface ReminderUpdateWithoutRecipientsDataInput {
  title?: String;
  message?: String;
  description?: String;
  author?: UserUpdateOneRequiredWithoutRemindersInput;
  frequency?: CronUpdateOneWithoutReminderInput;
  sentReminders?: NotificationUpdateManyWithoutParentReminderInput;
}

export interface ReminderUpdateWithWhereUniqueWithoutRecipientsInput {
  where: ReminderWhereUniqueInput;
  data: ReminderUpdateWithoutRecipientsDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface CronCreateWithoutReminderInput {
  plainText: String;
  cronText: String;
}

export interface ReminderCreateWithoutFrequencyInput {
  title?: String;
  message?: String;
  description?: String;
  recipients?: RecipientCreateManyWithoutRemindersInput;
  author: UserCreateOneWithoutRemindersInput;
  sentReminders?: NotificationCreateManyWithoutParentReminderInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email?: String;
  name: String;
  password: String;
  type?: Int;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  type: () => Promise<Int>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<Int>>;
}

export interface RecipientConnection {}

export interface RecipientConnectionPromise
  extends Promise<RecipientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RecipientEdge>>() => T;
  aggregate: <T = AggregateRecipientPromise>() => T;
}

export interface RecipientConnectionSubscription
  extends Promise<AsyncIterator<RecipientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RecipientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRecipientSubscription>() => T;
}

export interface Reminder {
  id: ID_Output;
  title: String;
  message?: String;
  description?: String;
  createdAt: DateTimeOutput;
}

export interface ReminderPromise extends Promise<Reminder>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  message: () => Promise<String>;
  description: () => Promise<String>;
  recipients: <T = FragmentableArray<Recipient>>(
    args?: {
      where?: RecipientWhereInput;
      orderBy?: RecipientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  author: <T = UserPromise>() => T;
  frequency: <T = CronPromise>() => T;
  sentReminders: <T = FragmentableArray<Notification>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ReminderSubscription
  extends Promise<AsyncIterator<Reminder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  message: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  recipients: <T = Promise<AsyncIterator<RecipientSubscription>>>(
    args?: {
      where?: RecipientWhereInput;
      orderBy?: RecipientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  author: <T = UserSubscription>() => T;
  frequency: <T = CronSubscription>() => T;
  sentReminders: <T = Promise<AsyncIterator<NotificationSubscription>>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CronConnection {}

export interface CronConnectionPromise
  extends Promise<CronConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CronEdge>>() => T;
  aggregate: <T = AggregateCronPromise>() => T;
}

export interface CronConnectionSubscription
  extends Promise<AsyncIterator<CronConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CronEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCronSubscription>() => T;
}

export interface NotificationEdge {
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface NotificationConnection {}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email?: String;
  name: String;
  password: String;
  type?: Int;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  reminders: <T = FragmentableArray<Reminder>>(
    args?: {
      where?: ReminderWhereInput;
      orderBy?: ReminderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  recipient: <T = FragmentableArray<Recipient>>(
    args?: {
      where?: RecipientWhereInput;
      orderBy?: RecipientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  type: () => Promise<Int>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  reminders: <T = Promise<AsyncIterator<ReminderSubscription>>>(
    args?: {
      where?: ReminderWhereInput;
      orderBy?: ReminderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  recipient: <T = Promise<AsyncIterator<RecipientSubscription>>>(
    args?: {
      where?: RecipientWhereInput;
      orderBy?: RecipientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  type: () => Promise<AsyncIterator<Int>>;
}

export interface Recipient {
  id: ID_Output;
  name: String;
  contactMethod?: ContactMethod;
  contactInfo?: String;
}

export interface RecipientPromise extends Promise<Recipient>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  reminders: <T = FragmentableArray<Reminder>>(
    args?: {
      where?: ReminderWhereInput;
      orderBy?: ReminderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  contactMethod: () => Promise<ContactMethod>;
  contactInfo: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface RecipientSubscription
  extends Promise<AsyncIterator<Recipient>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  reminders: <T = Promise<AsyncIterator<ReminderSubscription>>>(
    args?: {
      where?: ReminderWhereInput;
      orderBy?: ReminderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  contactMethod: () => Promise<AsyncIterator<ContactMethod>>;
  contactInfo: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface ReminderSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ReminderSubscriptionPayloadPromise
  extends Promise<ReminderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReminderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReminderPreviousValuesPromise>() => T;
}

export interface ReminderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReminderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReminderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReminderPreviousValuesSubscription>() => T;
}

export interface ReminderPreviousValues {
  id: ID_Output;
  title: String;
  message?: String;
  description?: String;
  createdAt: DateTimeOutput;
}

export interface ReminderPreviousValuesPromise
  extends Promise<ReminderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  message: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ReminderPreviousValuesSubscription
  extends Promise<AsyncIterator<ReminderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  message: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Cron {
  id: ID_Output;
  plainText: String;
  cronText: String;
}

export interface CronPromise extends Promise<Cron>, Fragmentable {
  id: () => Promise<ID_Output>;
  plainText: () => Promise<String>;
  cronText: () => Promise<String>;
  reminder: <T = ReminderPromise>() => T;
}

export interface CronSubscription
  extends Promise<AsyncIterator<Cron>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  plainText: () => Promise<AsyncIterator<String>>;
  cronText: () => Promise<AsyncIterator<String>>;
  reminder: <T = ReminderSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface CronSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CronSubscriptionPayloadPromise
  extends Promise<CronSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CronPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CronPreviousValuesPromise>() => T;
}

export interface CronSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CronSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CronSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CronPreviousValuesSubscription>() => T;
}

export interface AggregateReminder {
  count: Int;
}

export interface AggregateReminderPromise
  extends Promise<AggregateReminder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReminderSubscription
  extends Promise<AsyncIterator<AggregateReminder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CronPreviousValues {
  id: ID_Output;
  plainText: String;
  cronText: String;
}

export interface CronPreviousValuesPromise
  extends Promise<CronPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  plainText: () => Promise<String>;
  cronText: () => Promise<String>;
}

export interface CronPreviousValuesSubscription
  extends Promise<AsyncIterator<CronPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  plainText: () => Promise<AsyncIterator<String>>;
  cronText: () => Promise<AsyncIterator<String>>;
}

export interface ReminderConnection {}

export interface ReminderConnectionPromise
  extends Promise<ReminderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReminderEdge>>() => T;
  aggregate: <T = AggregateReminderPromise>() => T;
}

export interface ReminderConnectionSubscription
  extends Promise<AsyncIterator<ReminderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReminderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReminderSubscription>() => T;
}

export interface AggregateCron {
  count: Int;
}

export interface AggregateCronPromise
  extends Promise<AggregateCron>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCronSubscription
  extends Promise<AsyncIterator<AggregateCron>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RecipientEdge {
  cursor: String;
}

export interface RecipientEdgePromise
  extends Promise<RecipientEdge>,
    Fragmentable {
  node: <T = RecipientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RecipientEdgeSubscription
  extends Promise<AsyncIterator<RecipientEdge>>,
    Fragmentable {
  node: <T = RecipientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface RecipientPreviousValues {
  id: ID_Output;
  name: String;
  contactMethod?: ContactMethod;
  contactInfo?: String;
}

export interface RecipientPreviousValuesPromise
  extends Promise<RecipientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  contactMethod: () => Promise<ContactMethod>;
  contactInfo: () => Promise<String>;
}

export interface RecipientPreviousValuesSubscription
  extends Promise<AsyncIterator<RecipientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  contactMethod: () => Promise<AsyncIterator<ContactMethod>>;
  contactInfo: () => Promise<AsyncIterator<String>>;
}

export interface RecipientSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RecipientSubscriptionPayloadPromise
  extends Promise<RecipientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RecipientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RecipientPreviousValuesPromise>() => T;
}

export interface RecipientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RecipientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RecipientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RecipientPreviousValuesSubscription>() => T;
}

export interface CronEdge {
  cursor: String;
}

export interface CronEdgePromise extends Promise<CronEdge>, Fragmentable {
  node: <T = CronPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CronEdgeSubscription
  extends Promise<AsyncIterator<CronEdge>>,
    Fragmentable {
  node: <T = CronSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NotificationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  scheduledDelivery: DateTimeOutput;
  status?: Status;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  scheduledDelivery: () => Promise<DateTimeOutput>;
  status: () => Promise<Status>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  scheduledDelivery: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<Status>>;
}

export interface ReminderEdge {
  cursor: String;
}

export interface ReminderEdgePromise
  extends Promise<ReminderEdge>,
    Fragmentable {
  node: <T = ReminderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReminderEdgeSubscription
  extends Promise<AsyncIterator<ReminderEdge>>,
    Fragmentable {
  node: <T = ReminderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Notification {
  id: ID_Output;
  createdAt: DateTimeOutput;
  scheduledDelivery: DateTimeOutput;
  status?: Status;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parentReminder: <T = ReminderPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  scheduledDelivery: () => Promise<DateTimeOutput>;
  status: () => Promise<Status>;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentReminder: <T = ReminderSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  scheduledDelivery: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<Status>>;
}

export interface AggregateRecipient {
  count: Int;
}

export interface AggregateRecipientPromise
  extends Promise<AggregateRecipient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRecipientSubscription
  extends Promise<AsyncIterator<AggregateRecipient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "ContactMethod",
    embedded: false
  },
  {
    name: "Cron",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "Recipient",
    embedded: false
  },
  {
    name: "Reminder",
    embedded: false
  },
  {
    name: "Status",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
